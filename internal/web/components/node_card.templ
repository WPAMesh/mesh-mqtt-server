package components

import (
	"encoding/json"
	"fmt"
)

func nodeValidationErrorsJSON(nodes []NodeData) string {
	errors := make(map[string][]string)
	for _, node := range nodes {
		if node.NodeID != "" && len(node.ValidationErrors) > 0 {
			errors[node.NodeID] = node.ValidationErrors
		}
	}
	data, _ := json.Marshal(errors)
	return string(data)
}

// NodeCard renders a single node card
templ NodeCard(node NodeData) {
	<div class="node-card border rounded-2xl" style={ fmt.Sprintf("--node-color: %s; --node-color-bg: %s26;", getNodeColor(node), getNodeColor(node)) }>
		<!-- Header -->
		<div class="node-header">
			<div class="node-header-left">
				<span class="node-badge">{ getShortName(node) }</span>
				<span class="node-name">{ getLongName(node) }</span>
			</div>
			<div class="flex items-center">
				@proxyIcon(node.ProxyType)
			</div>
		</div>

		<!-- Root topic -->
		<div class="node-topic">
			Topic: <code>{ node.RootTopic }</code>
		</div>

		<!-- Downlink + Gateway Status -->
		<div class="node-status-row">
			<div class={ statusBadgeClass(node.IsDownlink) }>
				<i class={ statusIconClass(node.IsDownlink) }></i>
				<span>Downlink</span>
			</div>
			<div
				class={ statusBadgeClickableClass(node.IsValidGateway) }
				data-node-id={ node.NodeID }
				data-node-name={ getLongName(node) }
				data-is-valid={ boolStr(node.IsValidGateway) }
				onclick="showValidationErrors(this)"
				if !node.IsValidGateway {
					title="Click to see validation errors"
				}
			>
				<i class={ statusIconClass(node.IsValidGateway) }></i>
				<span>Valid GW</span>
			</div>
		</div>

		<!-- Connection Info -->
		<div class="node-info-row">
			<span class="node-info-text">{ getIPAddress(node) }</span>
			<span class="node-info-text">{ getNodeRole(node) }</span>
			<span class="node-info-text">{ getNodeID(node) }</span>
		</div>
	</div>
}

// NodeGrid renders a grid of node cards (SSE updates handled by vanilla JS)
templ NodeGrid(nodes []NodeData) {
	<div id="node-grid" class="node-grid">
		if len(nodes) == 0 {
			<div class="no-nodes-message"><i>No nodes found</i></div>
		} else {
			for _, node := range nodes {
				@NodeCard(node)
			}
		}
		<!-- Store validation errors as data attribute for modal -->
		@ValidationErrorsData(nodes)
	</div>
}

// NodeGridContent renders just the node cards content (for SSE updates)
templ NodeGridContent(nodes []NodeData) {
	if len(nodes) == 0 {
		<div class="no-nodes-message"><i>No nodes found</i></div>
	} else {
		for _, node := range nodes {
			@NodeCard(node)
		}
	}
	@ValidationErrorsData(nodes)
}

// ValidationErrorsData renders a script that stores validation errors for the modal
templ ValidationErrorsData(nodes []NodeData) {
	@templ.Raw("<script>window.nodeValidationErrors = Object.assign(window.nodeValidationErrors || {}, " + nodeValidationErrorsJSON(nodes) + ");</script>")
}

// NodeTableRow renders a single row in the nodes table (for admin view)
// On desktop: traditional table row with all columns
// On mobile: compact 2-line row that expands on tap
templ NodeTableRow(node NodeData, showUser bool) {
	<tr
		class={ "node-row", tableRowClass(node) }
		data-node-id={ node.NodeID }
		onclick="toggleNodeRow(this)"
	>
		<!-- Desktop columns (hidden on mobile via CSS) -->
		<td class="desktop-only">{ node.NodeID }</td>
		<td class="desktop-only">{ getShortName(node) }</td>
		<td class="desktop-only">{ getLongName(node) }</td>
		<td class="desktop-only topic-cell" title={ node.RootTopic }>{ truncateTopic(node.RootTopic) }</td>
		<td class="desktop-only">
			if node.ProxyType != "" {
				{ node.ProxyType }
			} else {
				<i>none</i>
			}
		</td>
		<td class="desktop-only">
			if node.IsConnected {
				{ node.Address }
			} else {
				<i>disconnected</i>
			}
		</td>
		<td class="desktop-only">
			if node.IsDownlink {
				Yes
			} else {
				No
			}
		</td>
		<td
			class="desktop-only gw-status-cell"
			data-node-id={ node.NodeID }
			data-node-name={ getLongName(node) }
			data-is-valid={ boolStr(node.IsValidGateway) }
			onclick="event.stopPropagation(); showValidationErrors(this)"
			if !node.IsValidGateway && len(node.ValidationErrors) > 0 {
				title="Click to see validation errors"
			}
		>
			if node.IsValidGateway {
				<span class="gw-badge gw-valid">Yes</span>
			} else {
				<span class="gw-badge gw-invalid">No</span>
			}
		</td>
		if showUser {
			<td class="desktop-only">{ node.UserDisplay }</td>
		}
		<!-- Mobile compact view (hidden on desktop) -->
		<td class="mobile-only" colspan={ mobileColSpan(showUser) }>
			<div class="compact-row-header">
				<span class="node-badge-sm" style={ fmt.Sprintf("background-color: %s;", getNodeColor(node)) }>{ getShortName(node) }</span>
				<span class="node-name-compact">{ getLongName(node) }</span>
				<div class="status-dots">
					<span class={ connectionDotClass(node) } title={ connectionDotTitle(node) }></span>
					<span class={ validationDotClass(node) } title={ validationDotTitle(node) }></span>
					<span class={ gatewayDotClass(node) } title={ gatewayDotTitle(node) }></span>
				</div>
				<i class="fas fa-chevron-down expand-icon"></i>
			</div>
			<div class="compact-row-subtext">
				{ getIPAddress(node) } &bull; { node.NodeID }
				if showUser {
					 &bull; { node.UserDisplay }
				}
			</div>
		</td>
	</tr>
	<!-- Expandable details row (mobile only) -->
	<tr class="node-details-row" data-parent={ node.NodeID }>
		<td colspan={ mobileColSpan(showUser) }>
			<div class="expanded-content">
				<div class="detail-grid">
					<div class="detail-item">
						<span class="detail-label">Root Topic</span>
						<code class="detail-value topic-value">{ node.RootTopic }</code>
					</div>
					<div class="detail-item">
						<span class="detail-label">Role</span>
						<span class="detail-value">{ getNodeRole(node) }</span>
					</div>
					<div class="detail-item">
						<span class="detail-label">Proxy</span>
						<span class="detail-value">
							if node.ProxyType != "" {
								{ node.ProxyType }
							} else {
								None
							}
						</span>
					</div>
					<div class="detail-item">
						<span class="detail-label">Downlink</span>
						<span class="detail-value">
							if node.IsDownlink {
								Yes
							} else {
								No
							}
						</span>
					</div>
					<div class="detail-item">
						<span class="detail-label">Valid Gateway</span>
						<span class="detail-value">
							if node.IsValidGateway {
								Yes
							} else {
								No
							}
						</span>
					</div>
					<div class="detail-item">
						<span class="detail-label">HW Model</span>
						<span class="detail-value">{ node.HwModel }</span>
					</div>
				</div>
				if len(node.ValidationErrors) > 0 {
					<div class="validation-errors-compact">
						<span class="error-label"><i class="fas fa-exclamation-triangle"></i> Validation Errors</span>
						<ul>
							for _, err := range node.ValidationErrors {
								<li>{ err }</li>
							}
						</ul>
					</div>
				}
			</div>
		</td>
	</tr>
}

// NodesTable renders a table of nodes (for admin view, SSE updates handled by vanilla JS)
templ NodesTable(nodes []NodeData, showUser bool) {
	<table class="table--responsive nodes-table" id="nodes-table">
		<thead>
			<tr>
				<th>Node ID</th>
				<th colspan="2">Name</th>
				<th>Root Topic</th>
				<th>Proxy</th>
				<th>Address</th>
				<th>Downlink?</th>
				<th>Valid <abbr title="gateway">GW</abbr>?</th>
				if showUser {
					<th>User</th>
				}
			</tr>
		</thead>
		<tbody id="nodes-tbody">
			@NodesTableContent(nodes, showUser)
		</tbody>
	</table>
}

// NodesTableContent renders just the table body content (for SSE updates)
templ NodesTableContent(nodes []NodeData, showUser bool) {
	if len(nodes) == 0 {
		<tr>
			<td colspan={ colSpan(showUser) }><i>No nodes found</i></td>
		</tr>
	} else {
		for _, node := range nodes {
			@NodeTableRow(node, showUser)
		}
	}
}

// BridgeClientsTable renders a table of MeshCore bridge clients
// SSE updates handled by vanilla JS
templ BridgeClientsTable(clients []BridgeClientData, showUser bool) {
	<table class="table--responsive" id="bridge-clients-table">
		<thead>
			<tr>
				<th>Client ID</th>
				<th>Address</th>
				if showUser {
					<th>User</th>
				}
			</tr>
		</thead>
		<tbody id="bridge-clients-tbody">
			@BridgeClientsTableContent(clients, showUser)
		</tbody>
	</table>
}

// BridgeClientsTableContent renders just the bridge clients table content (for SSE updates)
templ BridgeClientsTableContent(clients []BridgeClientData, showUser bool) {
	if len(clients) == 0 {
		<tr>
			<td colspan={ otherClientsColSpan(showUser) }><i>No bridge clients</i></td>
		</tr>
	} else {
		for _, client := range clients {
			<tr>
				<td>{ client.ClientID }</td>
				<td>
					if client.Address != "" {
						{ client.Address }
					} else {
						<i>disconnected</i>
					}
				</td>
				if showUser {
					<td>{ client.UserDisplay }</td>
				}
			</tr>
		}
	}
}

// OtherClientsTable renders a table of other (non-mesh) clients
// SSE updates handled by vanilla JS
templ OtherClientsTable(clients []OtherClientData, showUser bool) {
	<table class="table--responsive" id="other-clients-table">
		<thead>
			<tr>
				<th>Client ID</th>
				<th>Address</th>
				if showUser {
					<th>User</th>
				}
			</tr>
		</thead>
		<tbody id="other-clients-tbody">
			@OtherClientsTableContent(clients, showUser)
		</tbody>
	</table>
}

// OtherClientsTableContent renders just the other clients table content (for SSE updates)
templ OtherClientsTableContent(clients []OtherClientData, showUser bool) {
	if len(clients) == 0 {
		<tr>
			<td colspan={ otherClientsColSpan(showUser) }><i>No other clients</i></td>
		</tr>
	} else {
		for _, client := range clients {
			<tr>
				<td>{ client.ClientID }</td>
				<td>
					if client.Address != "" {
						{ client.Address }
					} else {
						<i>disconnected</i>
					}
				</td>
				if showUser {
					<td>{ client.UserDisplay }</td>
				}
			</tr>
		}
	}
}

// Helper functions

func getNodeColor(node NodeData) string {
	if node.NodeColor != "" {
		return node.NodeColor
	}
	return "#808080"
}

func getShortName(node NodeData) string {
	if node.ShortName != "" {
		return node.ShortName
	}
	return "?"
}

func getLongName(node NodeData) string {
	if node.LongName != "" {
		return node.LongName
	}
	return "unknown"
}

func getNodeRole(node NodeData) string {
	if node.NodeRole != "" {
		return node.NodeRole
	}
	return "n/a"
}

func getNodeID(node NodeData) string {
	if node.NodeID != "" {
		return node.NodeID
	}
	return "n/a"
}

func getIPAddress(node NodeData) string {
	if node.Address != "" {
		// Split host:port and return just the host
		for i := len(node.Address) - 1; i >= 0; i-- {
			if node.Address[i] == ':' {
				return node.Address[:i]
			}
		}
		return node.Address
	}
	return "disconnected"
}

func boolStr(b bool) string {
	if b {
		return "true"
	}
	return "false"
}

func statusBadgeClass(isSuccess bool) string {
	if isSuccess {
		return "status-badge status-badge-success"
	}
	return "status-badge status-badge-error"
}

func statusBadgeClickableClass(isSuccess bool) string {
	if isSuccess {
		return "status-badge status-badge-clickable status-badge-success"
	}
	return "status-badge status-badge-clickable status-badge-error"
}

func statusIconClass(isSuccess bool) string {
	if isSuccess {
		return "fas fa-check-circle"
	}
	return "fas fa-times-circle"
}

func tableRowClass(node NodeData) string {
	if len(node.ValidationErrors) > 0 {
		return "has-errors"
	}
	return ""
}

func tableRowTitle(node NodeData) string {
	if len(node.ValidationErrors) > 0 {
		title := "Validation errors: "
		for i, err := range node.ValidationErrors {
			if i > 0 {
				title += ", "
			}
			title += err
		}
		return title
	}
	return ""
}

func colSpan(showUser bool) string {
	if showUser {
		return "10"
	}
	return "9"
}

func otherClientsColSpan(showUser bool) string {
	if showUser {
		return "3"
	}
	return "2"
}

func mobileColSpan(showUser bool) string {
	if showUser {
		return "10"
	}
	return "9"
}

func truncateTopic(topic string) string {
	if len(topic) > 25 {
		return topic[:22] + "..."
	}
	return topic
}

// Status dot helper functions for mobile view
func connectionDotClass(node NodeData) string {
	if node.IsConnected {
		return "status-dot connected"
	}
	return "status-dot disconnected"
}

func connectionDotTitle(node NodeData) string {
	if node.IsConnected {
		return "Connected"
	}
	return "Disconnected"
}

func validationDotClass(node NodeData) string {
	if len(node.ValidationErrors) > 0 {
		return "status-dot has-errors"
	}
	return "status-dot no-errors"
}

func validationDotTitle(node NodeData) string {
	if len(node.ValidationErrors) > 0 {
		return fmt.Sprintf("%d validation error(s)", len(node.ValidationErrors))
	}
	return "No validation errors"
}

func gatewayDotClass(node NodeData) string {
	if node.IsValidGateway {
		return "status-dot valid-gw"
	}
	return "status-dot invalid-gw"
}

func gatewayDotTitle(node NodeData) string {
	if node.IsValidGateway {
		return "Valid gateway"
	}
	return "Not a valid gateway"
}

templ proxyIcon(proxyType string) {
	if proxyType == "Android" {
		<i class="fab fa-android text-xl ml-2" title="Android Proxy"></i>
	} else if proxyType == "Apple" {
		<i class="fab fa-apple text-xl ml-2" title="iOS Proxy"></i>
	}
}
