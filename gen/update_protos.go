package main

import (
	"fmt"
	"io/fs"
	"os"
	"os/exec"
	"path"
	"path/filepath"

	"golang.org/x/mod/semver"

	"github.com/go-git/go-git/v6"
	"github.com/go-git/go-git/v6/plumbing"
	"github.com/go-git/go-git/v6/plumbing/object"

	//lint:ignore ST1001 looks better with dot imports
	. "github.com/dave/jennifer/jen"
)

func main() {

	// protoc  -I ./protobufs/ --go_out=. --go_opt=paths=source_relative ./protobufs/nanopb.proto ./protobufs/meshtastic/*.proto

	status, tag, commit := updateProtobufRepo()
	makeVersionFile(status, tag, commit)

	// This must be relative to the project root
	protoInDir := "./protobufs/"
	outDir := path.Join("pkg", "meshtastic")

	args := []string{"-I", protoInDir, "--go_out=./pkg/meshtastic", "--go_opt=paths=source_relative"}
	t := find(protoInDir, ".proto")
	args = append(args, t...)

	out, err := exec.Command("protoc", args...).Output()
	output := string(out[:])
	if err != nil {
		if ee, ok := err.(*exec.ExitError); ok {
			fmt.Println(string(ee.Stderr[:]))
		} else {
			fmt.Printf("%s\n%s\n", err, output)
		}
		return
	}

	if output != "" {
		fmt.Println(output)
	}

	finalPath := path.Join(outDir, "generated")
	_, err = os.Stat(finalPath)
	if err == nil {
		err = os.RemoveAll(finalPath)
		if err != nil {
			fmt.Printf("%s\n", err)
			return
		}
	}

	err = os.Rename(path.Join(outDir, "meshtastic"), path.Join(finalPath))
	if err != nil {
		fmt.Printf("%s\n", err)
		return
	}
	err = os.Rename(path.Join(outDir, "nanopb.pb.go"), path.Join(finalPath, "nanopb.pb.go"))
	if err != nil {
		fmt.Printf("%s\n", err)
		return
	}
	err = os.Rename(path.Join(outDir, "version.go"), path.Join(finalPath, "version.go"))
	if err != nil {
		fmt.Printf("%s\n", err)
		return
	}
	fmt.Println("Command Successfully Executed")
}

func find(root, ext string) []string {
	var a []string
	filepath.WalkDir(root, func(s string, d fs.DirEntry, e error) error {
		if e != nil {
			return e
		}
		if filepath.Ext(d.Name()) == ext {
			a = append(a, s)
		}
		return nil
	})
	return a
}

func updateProtobufRepo() (git.Status, *plumbing.Reference, *object.Commit) {
	repo, err := git.PlainOpen("./protobufs")
	if err != nil {
		panic(fmt.Errorf("failed to open git repository: %w", err))
	}

	err = repo.Fetch(&git.FetchOptions{RemoteName: "origin"})
	if err != nil && err != git.NoErrAlreadyUpToDate {
		panic(fmt.Errorf("failed to fetch latest protobufs: %w", err))
	}

	tagIter, err := repo.Tags()

	if err != nil {
		panic(fmt.Errorf("failed to retrieve tag information: %w", err))
	}
	versionTags := []string{}
	err = tagIter.ForEach(func(t *plumbing.Reference) error {
		if semver.IsValid(t.Name().Short()) {
			versionTags = append(versionTags, t.Name().Short())
		}
		return nil
	})
	if err != nil {
		panic(fmt.Errorf("failed to parse tags: %w", err))
	}

	semver.Sort(versionTags)
	latestTag, err := repo.Tag(versionTags[len(versionTags)-1])

	if err != nil {
		panic(fmt.Errorf("failed to get latest tag: %w", err))
	}
	worktree, err := repo.Worktree()
	if err != nil {
		panic(fmt.Errorf("failed to get git worktree: %w", err))
	}

	err = worktree.Checkout(&git.CheckoutOptions{Hash: latestTag.Hash()})
	if err != nil {
		panic(fmt.Errorf("failed to get latest tag: %w", err))
	}

	repoCommit, err := repo.CommitObject(latestTag.Hash())
	if err != nil {
		panic(fmt.Errorf("failed to get git commit: %w", err))
	}

	worktreeStatus, err := worktree.Status()
	if err != nil {
		panic(fmt.Errorf("failed to get git worktree status: %w", err))
	}

	return worktreeStatus, latestTag, repoCommit
}

func makeVersionFile(worktreeStatus git.Status, repoHead *plumbing.Reference, repoCommit *object.Commit) {
	f := NewFilePath("generated")

	f.HeaderComment("Code generated by gen/update_protos.go - DO NOT EDIT.")

	f.Const().Id("ProtobufDirty").Op("=").Lit(!worktreeStatus.IsClean())
	f.Const().Id("ProtobufSha").Op("=").Lit(repoHead.Hash().String())
	f.Const().Id("ProtobufTimestamp").Op("=").Lit(repoCommit.Author.When.Unix())
	f.Const().Id("ProtobufVersion").Op("=").Lit(repoHead.Name().Short())

	f.Func().Id("ProtobufTime").Params().Qual("time", "Time").Block(
		Return(Qual("time", "Unix").Call(Id("ProtobufTimestamp"), Lit(0))),
	)

	f.Func().Id("ProtobufDisplayVersion").Params().String().Block(
		Id("ver").Op(":=").Qual("fmt", "Sprintf").Params(
			Lit("%s-%s"),
			Id("ProtobufVersion"),
			Id("ProtobufSha").Index(Empty(), Lit(8)),
		),
		If(Id("ProtobufDirty")).Block(
			Id("ver").Op("=").Qual("fmt", "Sprintf").Params(Lit("%s-dirty"), Id("ver")),
		),
		Return(Id("ver")),
	)

	file := path.Join("pkg", "meshtastic", "version.go")
	fmt.Printf("saving file %v\n", file)
	if err := f.Save(file); err != nil {
		panic(fmt.Errorf("failed to save file: %w", err))
	}
}
